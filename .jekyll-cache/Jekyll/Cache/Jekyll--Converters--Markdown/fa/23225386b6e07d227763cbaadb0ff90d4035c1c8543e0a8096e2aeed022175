I"b§<ul id="markdown-toc">
  <li><a href="#machine-learning-part-2-dnn" id="markdown-toc-machine-learning-part-2-dnn">Machine Learning-Part 2-DNN</a>    <ul>
      <li><a href="#neural-networks-representation" id="markdown-toc-neural-networks-representation">Neural Networks: Representation</a>        <ul>
          <li><a href="#model-representation-i" id="markdown-toc-model-representation-i">Model Representation I</a></li>
          <li><a href="#model-representation-ii" id="markdown-toc-model-representation-ii">Model Representation II</a>            <ul>
              <li><a href="#examples-and-intuitions" id="markdown-toc-examples-and-intuitions">Examples and Intuitions</a></li>
            </ul>
          </li>
          <li><a href="#multiclass-classification" id="markdown-toc-multiclass-classification">Multiclass Classification</a></li>
        </ul>
      </li>
      <li><a href="#neural-networks-learning" id="markdown-toc-neural-networks-learning">Neural Networks: Learning</a>        <ul>
          <li><a href="#cost-function" id="markdown-toc-cost-function">Cost Function</a></li>
          <li><a href="#backpropagation-algorithm" id="markdown-toc-backpropagation-algorithm">Backpropagation Algorithm</a>            <ul>
              <li><a href="#mathematical-intuition" id="markdown-toc-mathematical-intuition">Mathematical Intuition:</a></li>
            </ul>
          </li>
          <li><a href="#backpropagation-intuition" id="markdown-toc-backpropagation-intuition">Backpropagation Intuition</a></li>
          <li><a href="#backpropagation-in-practice" id="markdown-toc-backpropagation-in-practice">Backpropagation in Practice</a></li>
          <li><a href="#gradient-checking" id="markdown-toc-gradient-checking">Gradient Checking</a></li>
          <li><a href="#random-initialization" id="markdown-toc-random-initialization">Random Initialization</a></li>
          <li><a href="#putting-it-together" id="markdown-toc-putting-it-together">Putting it Together</a></li>
          <li><a href="#codes" id="markdown-toc-codes">Codes</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="machine-learning-part-2-dnn">Machine Learning-Part 2-DNN</h1>
<p>by Andrew Ng</p>

<h2 id="neural-networks-representation">Neural Networks: Representation</h2>
<h3 id="model-representation-i">Model Representation I</h3>

<p>In neural networks, we use the same logistic function as in classification, $\frac{1}{1 + e^{-\theta^Tx}}$, yet we sometimes call it a sigmoid (logistic) <strong>activation</strong> function. In this situation, our ‚Äútheta‚Äù parameters are sometimes called ‚Äúweights‚Äù.</p>

<p>Visually, a simplistic representation looks like:</p>

\[\left[\begin{array}{l}{x_{0}} \\ {x_{1}} \\ {x_{2}}\end{array}\right] \rightarrow[\quad] \rightarrow h_{\theta}(x)\]

<p>Our input nodes (layer 1), also known as the ‚Äúinput layer‚Äù, go into another node (layer 2), which finally outputs the hypothesis function, known as the ‚Äúoutput layer‚Äù.</p>

<p>We can have intermediate layers of nodes between the input and output layers called the ‚Äúhidden layers.‚Äù</p>

<p>In this example, we label these intermediate or ‚Äúhidden‚Äù layer nodes $a_{0}^{2} \cdots a_{n}^{2}$ and call them ‚Äúactivation units.‚Äù</p>

\[\begin{array}{l}{a_{i}^{(j)}=\text { "activation" of unit } i \text { in layer } j} \\ {\Theta^{(j)}=\text { matrix of weights controlling function mapping from layer } j \text { to layer } j+1}\end{array}\]

<p>If we had one hidden layer, it would look like:</p>

\[\left[\begin{array}{l}{x_{0}} \\ {x_{1}} \\ {x_{2}} \\ {x_{3}}\end{array}\right] \rightarrow\left[\begin{array}{l}{a_{1}^{(2)}} \\ {a_{2}^{(2)}} \\ {a_{3}^{(2)}}\end{array}\right] \rightarrow h_{\theta}(x)\]

<p>The values for each of the ‚Äúactivation‚Äù nodes is obtained as follows:</p>

\[\begin{array}{r}{a_{1}^{(2)}=g\left(\Theta_{10}^{(1)} x_{0}+\Theta_{11}^{(1)} x_{1}+\Theta_{12}^{(1)} x_{2}+\Theta_{13}^{(1)} x_{3}\right)} \\ {a_{2}^{(2)}=g\left(\Theta_{20}^{(1)} x_{0}+\Theta_{21}^{(1)} x_{1}+\Theta_{22}^{(1)} x_{2}+\Theta_{23}^{(1)} x_{3}\right)} \\ {a_{3}^{(2)}=g\left(\Theta_{30}^{(1)} x_{0}+\Theta_{31}^{(1)} x_{1}+\Theta_{32}^{(1)} x_{2}+\Theta_{33}^{(1)} x_{3}\right)} \\ {h_{\Theta}(x)=a_{1}^{(3)}=g\left(\Theta_{10}^{(2)} a_{0}^{(2)}+\Theta_{11}^{(2)} a_{1}^{(2)}+\Theta_{12}^{(2)} a_{2}^{(2)}+\Theta_{13}^{(2)} a_{3}^{(2)}\right)}\end{array}\]

<p>This is saying that we compute our activation nodes by using a 3√ó4 matrix of parameters. We apply each row of the parameters to our inputs to obtain the value for one activation node. Our hypothesis output is the logistic function applied to the sum of the values of our activation nodes, which have been multiplied by yet another parameter matrix $\mathbf{\Theta}^{(2)}$ containing the weights for our second layer of nodes.</p>

<p>Each layer gets its own matrix of weights, $\Theta^{(j)}$.</p>

<p>The dimensions of these matrices of weights is determined as follows:</p>

<p>If network has sj units in layer j and $s_{j+1}$ units in layer j+1, then  $\Theta^{(j)}$ will be of dimension  $s_{j+1}*(s_{j}+1)$.</p>

<p>The +1 comes from the addition in $\Theta^{(j)}$ of the ‚Äúbias nodes,‚Äù $x_0$.</p>

<h3 id="model-representation-ii">Model Representation II</h3>

<p>In this section we‚Äôll do a vectorized implementation of the above functions. We‚Äôre going to define a new variable $z_k^{(j)}$ that encompasses the parameters inside our g function. In our previous example if we replaced by the variable z for all the parameters we would get:</p>

<p>$\begin{aligned} a_{1}^{(2)} &amp;=g\left(z_{1}^{(2)}\right) \ a_{2}^{(2)} &amp;=g\left(z_{2}^{(2)}\right) \ a_{3}^{(2)} &amp;=g\left(z_{3}^{(2)}\right) \end{aligned}$</p>

<p>In other words, for layer j=2 and node k, the variable z will be:</p>

<p>$z_{k}^{(2)}=\Theta_{k, 0}^{(1)} x_{0}+\Theta_{k, 1}^{(1)} x_{1}+\cdots+\Theta_{k, n}^{(1)} x_{n}$</p>

<p>The vector representation of x and $z^{j}$ is:</p>

<p>$x=\left[\begin{array}{l}{x_{0}} \ {x_{1}} \ {\cdots} \ {x_{n}}\end{array}\right] z^{(j)}=\left[\begin{array}{c}{z_{1}^{(j)}} \ {z_{2}^{(j)}} \ {\cdots} \ {z_{n}^{(j)}}\end{array}\right]$</p>

<p>Setting $x = a^{(1)}$, we can rewrite the equation as:</p>

<p>$z^{(j)}=\Theta^{(j-1)} a^{(j-1)}$</p>

<p>Now we can get a vector of our activation nodes for layer j as follows:</p>

<p>$a^{(j)}=g(z^{(j)})=g(\Theta^{(j-1)} a^{(j-1)})$</p>

<p>We can then add a bias unit (equal to 1) to layer j after we have computed $a^{(j)}$. This will be element $a_0^{(j)}$ and will be equal to 1. To compute our final hypothesis, let‚Äôs first compute another z vector:</p>

<p>$z^{(j+1)}=\Theta^{(j)} a^{(j)}$</p>

<p>This last theta matrix $\Theta^{(j)}$ will have only <strong>one row</strong> which is multiplied by one column $a^{(j)}$ so that our result is a single number. We then get our final result with:</p>

<p>$h_{\Theta}(x)=a^{(j+1)}=g(z^{(j+1)})$</p>

<p>Notice that in this <strong>last step</strong>, between layer j and layer j+1, we are doing <strong>exactly the same thing</strong> as we did in logistic regression. Adding all these intermediate layers in neural networks allows us to more elegantly produce interesting and more complex non-linear hypotheses.</p>

<h4 id="examples-and-intuitions">Examples and Intuitions</h4>

<p>The graph of our functions will look like:</p>

<p>$\left[\begin{array}{l}{x_{0}} \ {x_{1}} \ {x_{2}}\end{array}\right] \rightarrow\left[g\left(z^{(2)}\right)\right] \rightarrow h_{\Theta}(x)$</p>

<p>Remember that $¬†x_0$ is our bias variable and is always 1.</p>

<p>Let‚Äôs set our first theta matrix as:</p>

<p><strong>And</strong></p>

<p>Œò(1)=[‚àí30, 20, 20]</p>

<p>This will cause the output of our hypothesis to only be positive if both $x_1$ and $x_2$ are 1. In other words:</p>

\[\begin{array}{l}{h_{\Theta}(x)=g\left(-30+20 x_{1}+20 x_{2}\right)} \\ {x_{1}=0 \text { and } x_{2}=0 \text { then } g(-30) \approx 0} \\ {x_{1}=0 \text { and } x_{2}=1 \text { then } g(-10) \approx 0} \\ {x_{1}=1 \text { and } x_{2}=0 \text { then } g(-10) \approx 0} \\ {x_{1}=1 \text { and } x_{2}=1 \text { then } g(10) \approx 1}\end{array}\]

<p><strong>Or</strong></p>

<p>Œò(1)=[‚àí10, 20, 20]</p>

<p><strong>Not X</strong></p>

<p>Œò(1)=[10, -20]</p>

<p><strong>Not $X_1$ and Not $X_2$</strong></p>

<p>Œò(1)=[10, -20, -20]</p>

<h3 id="multiclass-classification">Multiclass Classification</h3>

<p>To classify data into multiple classes, we let our hypothesis function return a vector of values. Say we wanted to classify our data into one of four categories. We will use the following example to see how this classification is done. This algorithm takes as input an image and classifies it accordingly:</p>

<p>We can define our set of resulting classes as y:</p>

\[y^{(i)}=\left[\begin{array}{l}{1} \\ {0} \\ {0} \\ {0}\end{array}\right],\left[\begin{array}{l}{0} \\ {1} \\ {0} \\ {0}\end{array}\right],\left[\begin{array}{l}{0} \\ {0} \\ {1} \\ {0}\end{array}\right],\left[\begin{array}{l}{0} \\ {0} \\ {0} \\ {1}\end{array}\right]\]

<p>Each $y^{(i)}$ represents a different image corresponding to either a car, pedestrian, truck, or motorcycle. The inner layers, each provide us with some new information which leads to our final hypothesis function. The setup looks like:</p>

\[\left[\begin{array}{l}{x_{0}} \\ {x_{1}} \\ {x_{2}} \\ {\cdots} \\ {x_{n}}\end{array}\right] \rightarrow\left[\begin{array}{c}{a_{0}^{(2)}} \\ {a_{1}^{(2)}} \\ {a_{2}^{(2)}} \\ {\cdots}\end{array}\right] \rightarrow\left[\begin{array}{c}{a_{0}^{(3)}} \\ {a_{1}^{(3)}} \\ {a_{2}^{(3)}} \\ {\cdots}\end{array}\right] \rightarrow \cdots \rightarrow\left[\begin{array}{l}{h_{\Theta}(x)_{1}} \\ {h_{\Theta}(x)_{2}} \\ {h_{\Theta}(x)_{3}} \\ {h_{\Theta}(x)_{4}}\end{array}\right]\]

<p>Our resulting hypothesis for one set of inputs may look like:</p>

<p>$h_\Theta(x)=\left[\begin{array}{l}{0} \ {0} \ {1} \ {0}\end{array}\right]$</p>

<p>In which case our resulting class is the third one down, or $h_\Theta(x)_3=1$, which represents the motorcycle.</p>

<h2 id="neural-networks-learning">Neural Networks: Learning</h2>

<h3 id="cost-function">Cost Function</h3>

<p>Let‚Äôs first define a few variables that we will need to use:</p>

<ul>
  <li>L = total number of layers in the network</li>
  <li>$s_l$ = number of units (not counting bias unit) in layer l</li>
  <li>K = number of output units/classes</li>
</ul>

<p>Recall that in neural networks, we may have many output nodes. We denote $h_\Theta(x)_k$ as being a hypothesis that results in the $k^{th}$ output. Our cost function for neural networks is going to be a generalization of the one we used for logistic regression. Recall that the cost function for regularized logistic regression was:</p>

<p>$J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]+\frac{\lambda}{2 m} \sum_{j=1}^{n} \theta_{j}^{2}$</p>

<p>For neural networks, it is going to be slightly more complicated:</p>

\[J(\Theta)=-\frac{1}{m} \sum_{i=1}^{m} \sum_{k=1}^{K}\left[y_{k}^{(i)} \log \left(\left(h_{\Theta}\left(x^{(i)}\right)\right)_{k}\right)+\left(1-y_{k}^{(i)}\right) \log \left(1-\left(h_{\Theta}\left(x^{(i)}\right)\right)_{k}\right)\right]+\frac{\lambda}{2 m} \sum_{l=1}^{L-1} \sum_{i=1}^{s_{l}} \sum_{j=1}^{s_{l+1}}\left(\Theta_{j, i}^{(l)}\right)^{2}\]

<p>Note:</p>

<ul>
  <li>
    <p>For each layer, we do not regularize the $\Theta_{j,0}$,  just like we do not regularize the $\theta_0$ in the logistic regression.</p>
  </li>
  <li>
    <p>Therefore, even though $\Theta^{(l)}$ is a $s_{j+1}*(s_{j}+1)$ matrix, we do not regularize on the first column $\Theta(:,1)$.</p>
  </li>
</ul>

<h3 id="backpropagation-algorithm">Backpropagation Algorithm</h3>

<p>‚ÄúBackpropagation‚Äù is neural-network terminology for minimizing our cost function, just like what we were doing with gradient descent in logistic and linear regression. Our goal is to compute:</p>

<p>$\min_\Theta J(\Theta)$</p>

<p>That is, we want to minimize our cost function J using an optimal set of parameters in theta. In this section we‚Äôll look at the equations we use to compute the partial derivative of J(Œò):</p>

\[\begin{equation}
\frac{\partial}{\partial \Theta_{i, j}^{(l)}} J(\Theta)
\end{equation}\]

<p>To do so, we use the following algorithm:</p>

<p><strong>Back propagation Algorithm</strong>:</p>

<p>Given training set $\begin{equation}
\left{\left(x^{(1)}, y^{(1)}\right) \cdots\left(x^{(m)}, y^{(m)}\right)\right}
\end{equation}$.</p>

<ul>
  <li>Set $\Delta^{(l)}_{i,j}=0$ for all (l,i,j), (hence you end up having a matrix full of zeros)</li>
</ul>

<p>For training example t =1 to m:</p>

<ul>
  <li>Set $a^{(1)}:=x^{(t)}$</li>
  <li>Perform forward propagation to compute $a^{(l)}$  for l=2,3,‚Ä¶,L</li>
</ul>

\[\begin{equation}
\begin{aligned} a^{(1)  } &amp;=x ~~~~~~~~(add~ a_0^{(1)})\\ z^{(2)} &amp;=\Theta^{(1)} a^{(1)} \\ a^{(2)} &amp;=g\left(z^{(2)}\right) \left(\operatorname{add} a_{0}^{(2)}\right)\\ z^{(3)} &amp;=\Theta^{(2)} a^{(2)} \\ a^{(3)} &amp;=g\left(z^{(3)}\right)\left(\operatorname{add} a_{0}^{(3)}\right) \\ z^{(4)} &amp;=\Theta^{(3)} a^{(3)} \\ a^{(4)} &amp;=h_{\Theta}(x)=g\left(z^{(4)}\right) \end{aligned}
\end{equation}\]

<ul>
  <li>Using $y^{(t)}$, compute $\delta^{(L)} = a^{(L)} - y^{(t)}$</li>
</ul>

<p>Where L is our total number of layers and $a^{(L)}$ is the vector of outputs of the activation units for the last layer. So our ‚Äúerror values‚Äù for the last layer are simply the differences of our actual results in the last layer and the correct outputs in y. To get the delta values of the layers before the last layer, we can use an equation that steps us back from right to left:</p>

<ul>
  <li>Compute $\delta^{(L-1)}, \delta^{(L-2)},\dots,\delta^{(2)}$ using  $\begin{equation}
\delta^{(l)}=\left(\left(\Theta^{(l)}\right)^{T} \delta^{(l+1)}\right).*g‚Äô(z^{(l)}) \end{equation}$</li>
</ul>

<p>Since $g‚Äô(z^{(l)})= a^{(l)} \cdot *\left(1-a^{(l)}\right)$</p>

<p>$\begin{equation}
\delta^{(l)}=\left(\left(\Theta^{(l)}\right)^{T} \delta^{(l+1)}\right)\cdot * a^{(l)} \cdot *\left(1-a^{(l)}\right)
\end{equation}$</p>

<ul>
  <li>
    <p>$\begin{equation}
\Delta_{i, j}^{(l)} :=\Delta_{i, j}^{(l)}+ \delta_{i}^{(l+1)}a_{j}^{(l)}
\end{equation}$ or with <strong>vectorization</strong>, $\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T$</p>
  </li>
  <li>Note, we need to remove the $\delta_0^{(l)}$ for $l&lt;L$ for the calculation of  $\Delta^{(l)}$;</li>
  <li>This is because the $\Delta_{i, j}^{(l)}$ should have dimension of $s_{l+1}\times s_{l}+1$</li>
  <li>But for $l+1&lt;L$, $\delta^{(l+1)}$ has dimension of $s_{l+1}+1$. Therefore, we should delete this term.</li>
</ul>

<p>Hence we update our new $\Delta$ matrix:</p>

\[\begin{array}{l}{ D_{i, j}^{(l)} :=\frac{1}{m}\sum_{all~examples} \left(\Delta_{i, j}^{(l)}+\lambda \Theta_{i, j}^{(l)}\right), \text { if } j \neq 0} \\ { D_{i, j}^{(l)} :=\frac{1}{m} \sum_{all~examples} \Delta_{i, j}^{(l)} \text { ,  lf } j=0}\end{array}\]

<p>The capital-delta matrix D is used as an ‚Äúaccumulator‚Äù to add up our values as we go along and eventually compute our partial derivative. Thus we get</p>

<p>$\begin{equation}
\frac{\partial}{\partial \Theta_{i, j}^{(l)}} J(\Theta)
\end{equation}= D_{i, j}^{(l)}$.</p>

<h4 id="mathematical-intuition">Mathematical Intuition:</h4>
<p><img src="/media/15688038039566/15724489437384.jpg" alt="-w800" /></p>

<p><img src="/media/15688038039566/15724492275908.jpg" alt="-w800" /></p>

<hr />

<p><strong>For L2 norm or linear regression problem</strong>:
$W\in R^{m\times n}, x \in R^n , y\in R^n$
$f(x, W)=|W \cdot x|^{2}=\sum_{i=1}^{n}(W \cdot x)_{i}^{2}$, then we have:</p>

\[\nabla_{W} f=2 q \cdot x^{T} \\\nabla_{x} f=2 W^{T} \cdot q\]

<p>Note: the gradient w.r.t. any matrix/vector has the same shape with the matrix/vector.</p>

<hr />

<p><strong>For Logistic regression Problem</strong>:
$W\in R^{m\times n}, x \in R^n , y\in R^n$
$f(x, W)=-[(1-y) \cdot  log(1-Sigmoid(W\cdot x))+y\cdot log(Sigmoid(W\cdot x)) ]$, then we have:</p>

\[\nabla_{W} f= q \cdot x^{T} \\\nabla_{x} f= W^{T} \cdot q\]

<hr />
<p>$W\in R^{1 \times n}, x \in R^{n \times 1} , y\in R^1$
$f(x, W)=W\cdot x$, then we have:</p>

\[\nabla_{W} f= X^T \\\nabla_{x} f= W^{T}\]

<hr />

<p>$J(\Theta)=J(\Theta^{L-1}; a^{L-1})$ ;Where $a^{L-1}=g(\Theta^{L-2}*a^{L-2})$</p>

<p>$\frac{\partial J}{\partial \Theta^{L-1}}$ is just the like $\nabla_{W} f= q \cdot x^{T}$:</p>

\[\frac{\partial J}{\partial \Theta^{L-1}}=\delta^L*\left( a^{L-1}\right)^{T}\]

<!-- Combined with the fact:
$z^l=\Theta^{(l-1)}*a^{(l-1)}$
We have:$ \delta^L=\frac{\partial J}{\partial z^L }$-->

<p>Similar to the fact $\nabla_{x} f= W^{T} \cdot q$</p>

\[\frac{\partial J}{\partial a^{l-1}}=(\Theta^{L-1})^T(g(X\theta)-y)=(\Theta^{(L-1)})^T *\delta^{L}\\\]

<p>And for previous $\Theta^{L-2}$, since $a^{L-1}=g(\Theta^{L-2}*a^{L-1})$ is a function of  $\Theta^{L-2}$, we can use the chain rule to derive the $\frac{\partial J}{\partial \Theta^{L-2}}$ as:</p>

\[\begin{array}{lcl}
\frac{\partial J}{\partial \Theta^{L-2}}&amp;=&amp;\frac{\partial J}{\partial a^{L-1}}*\frac{\partial a^{L-1}}{\partial \Theta^{L-2}}
\\&amp;=&amp;(\Theta^{L-1})^T*\delta^L*g'(z^{L-1})*(a^{L-2})^T\\
&amp;=&amp;\delta^{L-1}*(a^{l-2})^T
\end{array}\]

<p>In other words:</p>

\[\frac{\partial J}{\partial \Theta^l}=\delta^{(l+1)}*(a^{(l)})^T
 \\
\delta^{(l)}=\left(\left(\Theta^{(l)}\right)^{T} \delta^{(l+1)}\right)\cdot * a^{(l)} \cdot *\left(1-a^{(l)}\right)\]

<h3 id="backpropagation-intuition">Backpropagation Intuition</h3>

<p>In the image above, to calculate $\delta_2^{(2)}$,  we multiply the weights $\Theta^{(2)}_{12}$ and</p>

\[\Theta^{(2)}_{22}\]

<p>by their respective $\delta$ values found to the right of each edge. So we get $\delta_{2}^{(2)}=\Theta_{12}^{(2)} \star \delta_{1}^{(3)}+\Theta_{22}^{(2)} \star \delta_{2}^{(3)}$. To calculate every single possible $\delta_j^{(l)}$, we could start from the right of our diagram. We can think of our edges as our $\Theta_{ij}$. Going from right to left, to calculate the value of $\delta_j^{(l)}$, you can just take the over all sum of each weight times the $\delta$ it is coming from. Hence, another example would be $\delta_2^{(3)}=\Theta^{(3)}_{12}\delta_1^{(4)}$</p>

<p>$Z=\Theta*X$</p>

<p>Since backwards, the true $\theta$, i.e. previous $\theta$, lies in $X$, the derivative will be like $(\Theta^{(l)})^T*\delta^{(l+1)}$</p>

<h3 id="backpropagation-in-practice">Backpropagation in Practice</h3>

<p>With neural networks, we are working with sets of matrices:</p>

\[\begin{array}{l}{\Theta^{(1)}, \Theta^{(2)}, \Theta^{(3)}, \ldots} \\ {D^{(1)}, D^{(2)}, D^{(3)}, \ldots}\end{array}\]

<p>In order to use optimizing functions such as ‚Äúfminunc()‚Äù, we will want to ‚Äúunroll‚Äù all the elements and put them into one long vector:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thetaVector</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Theta1</span><span class="p">(:);</span> <span class="n">Theta2</span><span class="p">(:);</span> <span class="n">Theta3</span><span class="p">(:);</span> <span class="p">]</span>
<span class="n">deltaVector</span> <span class="o">=</span> <span class="p">[</span> <span class="n">D1</span><span class="p">(:);</span> <span class="n">D2</span><span class="p">(:);</span> <span class="n">D3</span><span class="p">(:)</span> <span class="p">]</span>
</code></pre></div></div>

<p>If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11, then we can get back our original matrices from the ‚Äúunrolled‚Äù versions as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Theta1</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">thetaVector</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">110</span><span class="p">),</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="n">Theta2</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">thetaVector</span><span class="p">(</span><span class="mi">111</span><span class="p">:</span><span class="mi">220</span><span class="p">),</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="n">Theta3</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">thetaVector</span><span class="p">(</span><span class="mi">221</span><span class="p">:</span><span class="mi">231</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
</code></pre></div></div>

<p>To summarize:</p>

<ul>
  <li>Use to vector form for the optimization algorithms</li>
  <li>Use the matrix form to utilize the vectorization implementation.</li>
</ul>

<h3 id="gradient-checking">Gradient Checking</h3>

<p>Gradient checking will assure that our backpropagation works as intended. We can approximate the derivative of our cost function with:</p>

\[\frac{\partial}{\partial \Theta} J(\Theta) \approx \frac{J(\Theta+\epsilon)-J(\Theta-\epsilon)}{2 \epsilon}\]

<p>A small value for œµ (epsilon) such as œµ=$10^{‚àí4}$, guarantees that the math works out properly. If the value for œµ is too small, we can end up with numerical problems.</p>

<p>Hence, we are only adding or subtracting epsilon to the Œòj matrix. In octave we can do it as follows:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span>
  <span class="n">thetaPlus</span> <span class="o">=</span> <span class="n">theta</span><span class="p">;</span>
  <span class="n">thetaPlus</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">epsilon</span><span class="p">;</span>
  <span class="n">thetaMinus</span> <span class="o">=</span> <span class="n">theta</span><span class="p">;</span>
  <span class="n">thetaMinus</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-=</span> <span class="n">epsilon</span><span class="p">;</span>
  <span class="n">gradApprox</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="p">(</span><span class="n">thetaPlus</span><span class="p">)</span> <span class="o">-</span> <span class="n">J</span><span class="p">(</span><span class="n">thetaMinus</span><span class="p">))/(</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
<span class="k">end</span><span class="p">;</span>
</code></pre></div></div>

<p>We previously saw how to calculate the deltaVector. So once we compute our gradApprox vector, we can check that gradApprox ‚âà deltaVector.</p>

<p>Once you have verified <strong>once</strong> that your backpropagation algorithm is correct, you don‚Äôt need to compute gradApprox again. The code to compute gradApprox can be very slow.</p>

<h3 id="random-initialization">Random Initialization</h3>

<p>Initializing all theta weights to zero does not work with neural networks. When we backpropagate, all nodes will update to the same value repeatedly. Instead we can randomly initialize our weights for our Œò matrices using the following method:</p>

<p>Hence, we initialize each $\Theta^{(l)}_{ij}$ to a random value between[‚àíœµ,œµ]. Using the above formula guarantees that we get the desired bound. The same procedure applies to all the Œò‚Äôs. Below is some working code you could use to experiment.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">If</span> <span class="n">the</span> <span class="n">dimensions</span> <span class="n">of</span> <span class="n">Theta1</span> <span class="n">is</span> <span class="mi">10</span><span class="n">x11</span><span class="p">,</span> <span class="n">Theta2</span> <span class="n">is</span> <span class="mi">10</span><span class="n">x11</span> <span class="nb">and</span> <span class="n">Theta3</span> <span class="n">is</span> <span class="mi">1</span><span class="n">x11</span><span class="o">.</span>

<span class="n">Theta1</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">INIT_EPSILON</span><span class="p">)</span> <span class="o">-</span> <span class="n">INIT_EPSILON</span><span class="p">;</span>
<span class="n">Theta2</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">INIT_EPSILON</span><span class="p">)</span> <span class="o">-</span> <span class="n">INIT_EPSILON</span><span class="p">;</span>
<span class="n">Theta3</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">INIT_EPSILON</span><span class="p">)</span> <span class="o">-</span> <span class="n">INIT_EPSILON</span><span class="p">;</span>
</code></pre></div></div>

<p>rand(x,y) is just a function in octave that will initialize a matrix of random real numbers between 0 and 1.</p>

<p>(Note: the epsilon used above is unrelated to the epsilon from Gradient Checking)</p>

<h3 id="putting-it-together">Putting it Together</h3>

<p>First, pick a network architecture; choose the layout of your neural network, including how many hidden units in each layer and how many layers in total you want to have.</p>

<ul>
  <li>Number of input units = dimension of features $x^{(i)}$</li>
  <li>Number of output units = number of classes</li>
  <li>Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)</li>
  <li>Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.</li>
</ul>

<p><strong>Training a Neural Network</strong></p>

<ol>
  <li>Randomly initialize the weights</li>
  <li>Implement forward propagation to get $h_\Theta(x^{(i)})$ for any $x^{(i)}$</li>
  <li>Implement the cost function</li>
  <li>Implement backpropagation to compute partial derivatives</li>
  <li>Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.</li>
  <li>Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.</li>
</ol>

<p>When we perform forward and back propagation, we loop on every training example:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span>
   <span class="n">Perform</span> <span class="n">forward</span> <span class="n">propagation</span> <span class="nb">and</span> <span class="n">backpropagation</span> <span class="n">using</span> <span class="n">example</span> <span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
   <span class="p">(</span><span class="n">Get</span> <span class="n">activations</span> <span class="n">a</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="nb">and</span> <span class="n">delta</span> <span class="n">terms</span> <span class="n">d</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="k">...</span><span class="c">,L</span>
</code></pre></div></div>

<h3 id="codes">Codes</h3>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="p">[</span><span class="n">J</span> <span class="n">grad</span><span class="p">]</span> <span class="o">=</span> <span class="n">nnCostFunction</span><span class="p">(</span><span class="n">nn_params</span><span class="p">,</span> <span class="k">...</span>
                                   <span class="n">input_layer_size</span><span class="p">,</span> <span class="k">...</span>
                                   <span class="n">hidden_layer_size</span><span class="p">,</span> <span class="k">...</span>
                                   <span class="n">num_labels</span><span class="p">,</span> <span class="k">...</span>
                                   <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lambda</span><span class="p">)</span>
<span class="c1">%NNCOSTFUNCTION Implements the neural network cost function for a two layer</span>
<span class="c1">%neural network which performs classification</span>
<span class="c1">%   [J grad] = NNCOSTFUNCTON(nn_params, hidden_layer_size, num_labels, ...</span>
<span class="c1">%   X, y, lambda) computes the cost and gradient of the neural network. The</span>
<span class="c1">%   parameters for the neural network are "unrolled" into the vector</span>
<span class="c1">%   nn_params and need to be converted back into the weight matrices.</span>
<span class="c1">%</span>
<span class="c1">%   The returned parameter grad should be a "unrolled" vector of the</span>
<span class="c1">%   partial derivatives of the neural network.</span>
<span class="c1">%</span>

<span class="c1">% Reshape nn_params back into the parameters Theta1 and Theta2, the weight matrices</span>
<span class="c1">% for our 2 layer neural network</span>
<span class="n">Theta1</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nn_params</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">hidden_layer_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_layer_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="k">...</span>
                 <span class="n">hidden_layer_size</span><span class="p">,</span> <span class="p">(</span><span class="n">input_layer_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

<span class="n">Theta2</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nn_params</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">hidden_layer_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">input_layer_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))):</span><span class="k">end</span><span class="p">),</span> <span class="k">...</span>
                 <span class="n">num_labels</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden_layer_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

<span class="c1">% Setup some useful variables</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">% You need to return the following variables correctly</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Theta1_grad</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">Theta1</span><span class="p">));</span>
<span class="n">Theta2_grad</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">Theta2</span><span class="p">));</span>

<span class="c1">% ====================== YOUR CODE HERE ======================</span>
<span class="c1">% Instructions: You should complete the code by working through the</span>
<span class="c1">%               following parts.</span>
<span class="c1">%</span>
<span class="c1">% Part 1: Feedforward the neural network and return the cost in the</span>
<span class="c1">%         variable J. After implementing Part 1, you can verify that your</span>
<span class="c1">%         cost function computation is correct by verifying the cost</span>
<span class="c1">%         computed in ex4.m</span>
<span class="c1">%</span>
<span class="c1">% Part 2: Implement the backpropagation algorithm to compute the gradients</span>
<span class="c1">%         Theta1_grad and Theta2_grad. You should return the partial derivatives of</span>
<span class="c1">%         the cost function with respect to Theta1 and Theta2 in Theta1_grad and</span>
<span class="c1">%         Theta2_grad, respectively. After implementing Part 2, you can check</span>
<span class="c1">%         that your implementation is correct by running checkNNGradients</span>
<span class="c1">%</span>
<span class="c1">%         Note: The vector y passed into the function is a vector of labels</span>
<span class="c1">%               containing values from 1..K. You need to map this vector into a</span>
<span class="c1">%               binary vector of 1's and 0's to be used with the neural network</span>
<span class="c1">%               cost function.</span>
<span class="c1">%</span>
<span class="c1">%         Hint: We recommend implementing backpropagation using a for-loop</span>
<span class="c1">%               over the training examples if you are implementing it for the</span>
<span class="c1">%               first time.</span>
<span class="c1">%</span>
<span class="c1">% Part 3: Implement regularization with the cost function and gradients.</span>
<span class="c1">%</span>
<span class="c1">%         Hint: You can implement this around the code for</span>
<span class="c1">%               backpropagation. That is, you can compute the gradients for</span>
<span class="c1">%               the regularization separately and then add them to Theta1_grad</span>
<span class="c1">%               and Theta2_grad from Part 2.</span>
<span class="c1">%</span>

<span class="k">for</span> <span class="n">iter</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span>
    <span class="n">a1</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="n">X</span><span class="p">(</span><span class="n">iter</span><span class="p">,:)</span><span class="o">'</span><span class="p">];</span>
    <span class="n">yy</span><span class="o">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_labels</span><span class="p">);</span>
    <span class="n">yy</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">z2</span><span class="o">=</span><span class="n">Theta1</span><span class="o">*</span><span class="n">a1</span><span class="p">;</span>
    <span class="n">a2</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z2</span><span class="p">)];</span>
    <span class="n">z3</span><span class="o">=</span><span class="n">Theta2</span><span class="o">*</span><span class="n">a2</span><span class="p">;</span>
    <span class="n">a3</span><span class="o">=</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z3</span><span class="p">);</span>
    <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">yy</span><span class="o">*</span><span class="nb">log</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">yy</span><span class="p">)</span><span class="o">*</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a3</span><span class="p">));</span>

    <span class="n">delta3</span><span class="o">=</span><span class="n">a3</span><span class="o">-</span><span class="n">yy</span><span class="o">'</span><span class="p">;</span>
    <span class="c1">%fprintf('size of Theta2 is...[%d,%d] \n',size(Theta2))</span>
    <span class="c1">%fprintf('size of delta3 is...[%d,%d] \n',size(delta3))</span>
    <span class="c1">%fprintf('size of z2 is...[%d,%d] \n',size(z2))</span>

    <span class="n">delta2</span><span class="o">=</span> <span class="n">Theta2</span><span class="o">'*</span><span class="n">delta3</span><span class="o">.*</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="n">sigmoidGradient</span><span class="p">(</span><span class="n">z2</span><span class="p">)];</span>
    <span class="c1">% unless for delta Last one; other delta must delete first term;</span>
    <span class="n">delta2</span><span class="o">=</span><span class="n">delta2</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
    <span class="n">Theta2_grad</span> <span class="o">=</span> <span class="n">Theta2_grad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="n">delta3</span><span class="o">*</span><span class="n">a2</span><span class="o">'</span><span class="p">;</span>
    <span class="n">Theta1_grad</span> <span class="o">=</span> <span class="n">Theta1_grad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="n">delta2</span><span class="o">*</span><span class="n">a1</span><span class="o">'</span><span class="p">;</span>

<span class="k">end</span>


<span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">lambda</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nn_params</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">Theta1</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">Theta2</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span>

<span class="n">theta11</span><span class="o">=</span><span class="n">Theta1</span><span class="p">;</span>
<span class="n">theta11</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">theta22</span><span class="o">=</span><span class="n">Theta2</span><span class="p">;</span>
<span class="n">theta22</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="n">Theta2_grad</span> <span class="o">=</span> <span class="n">Theta2_grad</span> <span class="o">+</span> <span class="n">lambda</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="n">theta22</span><span class="p">;</span>
<span class="n">Theta1_grad</span> <span class="o">=</span> <span class="n">Theta1_grad</span> <span class="o">+</span> <span class="n">lambda</span><span class="p">/</span><span class="n">m</span><span class="o">*</span><span class="n">theta11</span><span class="p">;</span>

<span class="n">grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">Theta1_grad</span><span class="p">(:)</span> <span class="p">;</span> <span class="n">Theta2_grad</span><span class="p">(:)];</span>


<span class="k">end</span>

</code></pre></div></div>

:ET